\documentclass[10pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[dutch]{babel}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}

\author{Pieter Van Keymeulen}
\title{NonkelScript}

\begin{document}
\maketitle
\newpage

\tableofcontents
\newpage

\section{Introductie}
Bedrijven zijn er in alle soorten en maten. Niet ieder bedrijf heeft dezelfde specialisatie en iedere onderneming verkoopt andere diensten naargelang hun aard. Neem nu een horecabedrijf in vergelijking met een supermarkt. Een restaurant heeft een variabel aanbod. Het menu kan van dag tot dag wisselen, evenals de prijzen die zelfs kunnen variëren van uur tot uur. Een supermarkt daarentegen heeft een vast aantal producten en de prijzen van deze producten variëren niet zo vaak.

Bij het maken van een ERP systeem is het belangrijk dat we kunnen inspelen op de noden van de klant. We kunnen een ERP systeem zodanig maken dat de klant dit door middel van scripts kan aanpassen. In ons geval spreken we van scripts die de klant in staat stellen fouten die gebeuren binnen het systeem op te vangen. Dit kan gaan van simpele dingen zoals een printer die zonder inkt komt te liggen, tot meer complexe omstandigheden zoals het blokkeren van de productie van goederen. In beide gevallen moet er een soort fout gegenereerd worden die afgevangen kan worden. De klant zal deze fout op zijn eigen manier willen afhandelen. Door middel van onze scripttaal is dat van nu af aan mogelijk.

Nonkelscript is een scriptingtaal met ingebouwde multithreading. Als de verdere ontwikkelingen het ons toelaten zal de Nonkelscript interpreter in de toekomst kunnen draaien als daemon. Deze daemon zal in staat zijn de verschillende subsystemen van het ERP systeem te ondervragen. Verder zal de daemon enkele scripts toegewezen krijgen die gekoppeld kunnen worden aan een bepaalde fout die het ERP systeem kan genereren.

\section{Over programmeertalen}
\subsection{Geschiedenis}
%notities over deze sectie.
%Zorgen dat ik zo weinig mogelijk namen noem en, indien ik dit wel doe, ze eerst goed opzoek
%Evoor zorgen dat de aanhalingstekens goed getoond worden
Al vanaf het levenslicht van de eerste computer (De Z1 van Konrad Zuse) bestond er de nood om deze geweldige machines te programmeren. Computers moesten in staat zijn om een door de mens neergeschreven opdracht te kunnen uitvoeren. Dit konden hele complexe taken zijn. Van een simpele optelling tot het sorteren van een volledige reeks getallen. Een eerste poging tot het maken van zo een machine werd gedaan door Charles Babage. Het ontwerp van deze machine bleek echter te complex om ooit uitgevoerd te worden. Babbage had namelijk er geen rekening mee gehouden dat het arabische telsysteem veel complexer is dan het op het eerste gezicht lijkt. Dat bestaat namelijk uit 10 cijfers. Wat redelijk complex is om te implementeren gezien dat ieder cijfer voorgesteld moet worden. Dat betekent dat men 10 "states" nodig heeft om getallen te kunnen uitdrukken. Hoe moet dit uitgedrukt worden. Konrad Zuse had dit opgelost door het binaire systeem te gebruiken. Hierbij waren er slechts twee "states" nodig. Namelijk "waar" of "vals"
\subsection{Waarom niet één programmeertaal?}
Niet alles is even belangrijk op ieder werkveld. In de industrie is het vooral de veiligheid belangrijk. Stel dat er tijdens het productieproces bijvoorbeeld een fout zou gebeuren en dat het corrigeren van deze fout van groot belang is. Dan is het wenselijk dat de programma's die verantwoordelijk zijn voor het corrigeren van deze fout ook zo snel mogelijk kunnen reageren. Om dit te bereiken moet de gebruikte programmeertaal zo laag mogelijk zijn. Dit wil zeggen, zo dicht mogelijk aanliggen bij de eigenlijke werking van de machine. Dit laat de programmeur toe om enorm veel details van het programma te controleren.

Omgekeerd is ook mogelijk. het programmeren in assembler kan namelijk erg tijdrovend zijn. Zeker wanneer de te programmeren programma's ingewikkelder worden. Het is erg moeilijk een grafisch programma (maar niet onmogelijk) te maken met assembler. Ook omdat assembler een ongestructureerde programmeertaal is (meer hierover straks) en daarom de kans groot dat je uitkomt in zogenaamde "spaghetticode". Deze code wordt na verloop van tijd onhandelbaar. Het is dan wenselijk enige abstractie in de code te brengen. Dit kan door middel van in eerste instantie objectgeoriënteerd programmeren en, in tweede instantie proceduraal programmeren. Beide manier worden later in het verslag uitvoerig besproken.
\subsection{Waarom nog een nieuwe programmeertaal maken?}
%Hier vertellen over de mogelijkheid om de api van het nonkelerp systeem te integereren

\section{ERP systemen}

%vertel hier over de api van NonkelErp

\section{Bison en flex}
Bison en Flex zijn twee programma's die tezamen gebruikt kunnen worden voor het maken van een compiler. Met Flex kan er via reguliere expressies een "tokenizer" gemaakt worden die gebruikt kan worden om broncode te scannen op bepaalde sleutelwoorden. De informatie de Flex op deze manier verzameld kan op zijn beurt weer gebruikt worden door Bison. Deze vraagt de gescande sleutelwoorden kunnen gebruikt worden voor het opstellen van regels geschreven in Bakkus-Naur vorm. Aan iedere regel kan er een actie gekoppeld worden. Dit is een stuk code. Meestal is deze code geschreven in C, maar aangezien onze compiler in Delphi geschreven zal worden zal deze code dan ook Delphi zijn. De parser die uit deze verzameling regels gegenereerd zal worden zal naar iedere regel zoeken telkens wanneer er één van die regels gevonden wordt de gekoppelde actie uitvoeren. Op deze manier kan er op een efficiënte wijze een interpeter gemaakt worden.

\subsection{Flex}
Zoals eerder gezegd werkt flex door middel van reguliere expressies. Deze expressies kunnen net zoals in Bison gekoppeld worden aan een actie. Deze actie wordt net zoals in de Bison parser uitgevoerd. In een standaard Flex scanner doen deze acties niet zoveel. Eigenlijk geven ze gewoon tokens terug die correspondeert met de gevonden reguliere expressie. 

\subsection{Bison}
Bison is ongeveer hetzelfde als flex. Met het verschil dat bison de informatie van die flex doorgeeft opvangt, verwerkt, en vergelijkt met een aantal regels. De regels worden geschreven in bakkus-naur vorm. Ook deze regels zijn gekoppeld aan een actie die uitgevoerd wordt wanneer de regel in de broncode gevonden wordt.

In ons geval gaan we voor iedere gevonden regel een node maken en deze node in onze syntaxboom stoppen. Meer hierover straks.

\section{Interne structuur van de compiler}
Voor het programmeren van de compiler werd er gekozen voor Delphi. Wat niet een voor de hand liggende keuze is. Zowel Bison als Flex zijn immers beiden ontworpen om gebruikt te worden in combinatie met C. De reden voor deze vreemde keuze is dat de compiler moet kunnen integreren met een bestaand ERP systeem en dit systeem is geschreven in Delphi. Freepascal (de compiler die we gebruiken voor het bouwen van onze compiler) komt echter gebundeld met een programma dat in staat is om Bison en Flex code te converteren naar een Pascal unit. Hoewel deze tool is gemaakt in 2001 en eigenlijk bedoeld is voor gebruik in combinatie met Turbo Pascal volstaat het voor ons doel.

\begin{center}
\textbf{De procedure van broncode naar uitvoerbaar programma kan als volgt beschreven worden}
\end{center}

\paragraph{\textbf{front-end}}
Hier komt de tekst over de frontend

\paragraph{\textbf{Middle-end}}
hier komt de tekst over de middle end

\paragraph{\textbf{back-end}}
Hier komt de tekst over de back end

Zowel Flex als Bison zijn zogenaamde parsergenerators. Dit wil zeggen dat zij een formele grammatica aanvaarden. Deze formele grammatica is meestal opgeschreven in Bakus-Naur vorm. Nadat de parsergenerator de grammatica heeft verwerkt genereert deze een parser in een bepaalde doelprogrammeertaal. Dit kan in C, C++, Pascal en dergelijke zijn. Deze parser kan daarna als component in de compiler gebruikt worden en helpt bij het scannen en analyseren van de broncode.

\section{Design}
Onze compiler is gebaseerd op twee grote design pattern. Het composite design pattern, dat gebruikt wordt om de syntaxboom te bouwen en het interpreter design pattern, dat gebruikt wordt om de interpreter te bouwen. Beide zullen in dit hoofdstuk uitgelegd worden.

\subsection{Composite design pattern}
Het composite design pattern werd gebruikt voor het bouwen van de \emph{syntaxboom}. Dit is een datastructuur bestaande uit alle elementen die gevonden worden in heb bronbestand dat geïnterpreteerd dient te worden.

\subsection{Interpreter design pattern}

\section{Scripttaal}

\end{document}
